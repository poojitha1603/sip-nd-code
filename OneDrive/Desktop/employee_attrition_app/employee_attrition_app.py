# -*- coding: utf-8 -*-
"""Employee_Attrition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tOT_HXpO1E10XbzEdhGRmaEACpXQJ88w
"""



#upload the dataset
from google.colab import files
uploaded = files.upload()

import io
import pandas as pd

# replace the filename with your actual dataset name if different
df = pd.read_csv(io.BytesIO(uploaded['employeeattrition.csv']))
df.head()

#Explore the datasetprint
("Shape:", df.shape)   # rows, columns
print(df.info())            # datatypes
print(df['Attrition'].value_counts())  # target distribution

df.isnull().sum()  # check missing values

#Encode categorical columns

#Convert text ‚Üí numbers:

#Target column: Yes=1, No=0
df['Attrition'] = df['Attrition'].map({'Yes': 1, 'No': 0})

# One-hot encode other categorical columns
categorical_cols = df.select_dtypes(include=['object']).columns
df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)

df.head()

#Train-test split
from sklearn.model_selection import train_test_split

X = df.drop('Attrition', axis=1)
y = df['Attrition']

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print("Train shape:", X_train.shape)
print("Test shape:", X_test.shape)

#Train Logistic Regression Model
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Scale the features (Logistic Regression works better on scaled data)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Create Logistic Regression model
lr = LogisticRegression(max_iter=2000)  # max_iter is increased to ensure convergence
lr.fit(X_train_scaled, y_train)

# Predict on test set
y_pred = lr.predict(X_test_scaled)

# Evaluate performance
print("Logistic Regression Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Confusion matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix - Logistic Regression")
plt.show()

#save the trained model
import joblib

# Save the model and the scaler
joblib.dump(lr, 'employee_attrition_model.joblib')
joblib.dump(scaler, 'scaler.joblib')

print("Model and Scaler saved!")

from google.colab import files

files.download('employee_attrition_model.joblib')
files.download('scaler.joblib')

# Load saved model and scaler
loaded_model = joblib.load('employee_attrition_model.joblib')
loaded_scaler = joblib.load('scaler.joblib')

# Example: predict for first row in test set
sample = X_test.iloc[0:1]   # take first employee from test set
sample_scaled = loaded_scaler.transform(sample)
prediction = loaded_model.predict(sample_scaled)

print("Prediction (1 = Will Resign, 0 = Will Stay):", prediction)

!pip install gradio

import gradio as gr
import pandas as pd
import joblib

# Load model and scaler
loaded_model = joblib.load('employee_attrition_model.joblib')
loaded_scaler = joblib.load('scaler.joblib')

# Define the prediction function
def predict_attrition_simple(
    Age, MonthlyIncome, YearsAtCompany, OverTime,
    JobSatisfaction, DistanceFromHome, TotalWorkingYears,
    JobRole_Manager, JobRole_Sales, JobLevel
):
    # Create input dataframe
    input_dict = {
        'Age': [Age],
        'MonthlyIncome': [MonthlyIncome],
        'YearsAtCompany': [YearsAtCompany],
        'OverTime': [1 if OverTime=="Yes" else 0],
        'JobSatisfaction': [JobSatisfaction],
        'DistanceFromHome': [DistanceFromHome],
        'TotalWorkingYears': [TotalWorkingYears],
        'JobRole_Manager': [JobRole_Manager],
        'JobRole_Sales Executive': [JobRole_Sales],
        'JobLevel': [JobLevel]
    }

    input_df = pd.DataFrame(input_dict)

    # Add missing columns from training data (set to 0)
    for col in X_train.columns:
        if col not in input_df.columns:
            input_df[col] = 0

    input_df = input_df[X_train.columns]  # reorder columns

    # Scale and predict
    input_scaled = loaded_scaler.transform(input_df)
    prediction = loaded_model.predict(input_scaled)[0]

    return "‚ö†Ô∏è Employee is likely to RESIGN" if prediction == 1 else "‚úÖ Employee is likely to STAY"

demo_simple = gr.Interface(
    fn=predict_attrition_simple,
    inputs=[
        gr.Number(label="Age"),
        gr.Number(label="Monthly Income"),
        gr.Number(label="Years at Company"),
        gr.Radio(["Yes","No"], label="OverTime"),
        gr.Number(label="Job Satisfaction (1-4)"),
        gr.Number(label="Distance From Home"),
        gr.Number(label="Total Working Years"),
        gr.Radio([0,1], label="JobRole_Manager"),
        gr.Radio([0,1], label="JobRole_Sales Executive"),
        gr.Number(label="Job Level")
    ],
    outputs="text",
    title="üßë‚Äçüíº Employee Attrition Prediction (Simplified)"
)

demo_simple.launch(share=True)

demo_simple = gr.Interface(
    fn=predict_attrition_simple,
    inputs=[
        gr.Number(label="Age"),
        gr.Number(label="Monthly Income"),
        gr.Number(label="Years at Company"),
        gr.Radio(["Yes","No"], label="OverTime"),
        gr.Number(label="Job Satisfaction (1-4)"),
        gr.Number(label="Distance From Home"),
        gr.Number(label="Total Working Years"),
        gr.Radio([0,1], label="JobRole_Manager"),
        gr.Radio([0,1], label="JobRole_Sales Executive"),
        gr.Number(label="Job Level")
    ],
    outputs="text",
    title="üßë‚Äçüíº Employee Attrition Prediction (Simplified)"
)

demo_simple.launch(share=True)

